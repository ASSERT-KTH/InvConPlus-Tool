[
  {
    "description": "BinaryOpMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        uint256 c = a + b;\n+        require(c >= a, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b <= a, errorMessage);\n+        uint256 c = a - b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    /// BinaryOpMutation(`**` |==> `*`) of: `uint256 public totalSupply = 10*(10**18);`\n+    uint256 public totalSupply = 10*(10*18);\n+    uint256 public MaxSupply = 10*(10**(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        owner= msg.sender;\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "1",
    "name": "mutants/1/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  },
  {
    "description": "BinaryOpMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        uint256 c = a + b;\n+        require(c >= a, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b <= a, errorMessage);\n+        uint256 c = a - b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    uint256 public totalSupply = 10*(10**18);\n+    /// BinaryOpMutation(`**` |==> `+`) of: `uint256 public MaxSupply = 10*(10**(29));`\n+    uint256 public MaxSupply = 10*(10+(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        owner= msg.sender;\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "2",
    "name": "mutants/2/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  },
  {
    "description": "DeleteExpressionMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        uint256 c = a + b;\n+        require(c >= a, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b <= a, errorMessage);\n+        uint256 c = a - b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    uint256 public totalSupply = 10*(10**18);\n+    uint256 public MaxSupply = 10*(10**(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        /// DeleteExpressionMutation(`owner= msg.sender` |==> `assert(true)`) of: `owner= msg.sender;`\n+        assert(true);\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "3",
    "name": "mutants/3/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  },
  {
    "description": "DeleteExpressionMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        uint256 c = a + b;\n+        require(c >= a, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b <= a, errorMessage);\n+        uint256 c = a - b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    uint256 public totalSupply = 10*(10**18);\n+    uint256 public MaxSupply = 10*(10**(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        owner= msg.sender;\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        /// DeleteExpressionMutation(`require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\")` |==> `assert(true)`) of: `require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");`\n+        assert(true);\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "4",
    "name": "mutants/4/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        uint256 c = a + b;\n+        require(c >= a, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b <= a, errorMessage);\n+        uint256 c = a - b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    uint256 public totalSupply = 10*(10**18);\n+    uint256 public MaxSupply = 10*(10**(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        owner= msg.sender;\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        /// RequireMutation(`msg.sender==Tokenfarm` |==> `true`) of: `require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");`\n+        require(true,\"only Tokenfarm contract can mint tokens\");\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "5",
    "name": "mutants/5/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  },
  {
    "description": "BinaryOpMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        /// BinaryOpMutation(`+` |==> `*`) of: `uint256 c = a + b;`\n+        uint256 c = a*b;\n+        require(c >= a, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b <= a, errorMessage);\n+        uint256 c = a - b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    uint256 public totalSupply = 10*(10**18);\n+    uint256 public MaxSupply = 10*(10**(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        owner= msg.sender;\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "6",
    "name": "mutants/6/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  },
  {
    "description": "SwapArgumentsOperatorMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        uint256 c = a + b;\n+        /// SwapArgumentsOperatorMutation(`c >= a` |==> `a >= c`) of: `require(c >= a, \"SafeMath: addition overflow\");`\n+        require(a >= c, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b <= a, errorMessage);\n+        uint256 c = a - b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    uint256 public totalSupply = 10*(10**18);\n+    uint256 public MaxSupply = 10*(10**(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        owner= msg.sender;\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "7",
    "name": "mutants/7/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  },
  {
    "description": "RequireMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        uint256 c = a + b;\n+        require(c >= a, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        /// RequireMutation(`b <= a` |==> `false`) of: `require(b <= a, errorMessage);`\n+        require(false, errorMessage);\n+        uint256 c = a - b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    uint256 public totalSupply = 10*(10**18);\n+    uint256 public MaxSupply = 10*(10**(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        owner= msg.sender;\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "8",
    "name": "mutants/8/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  },
  {
    "description": "BinaryOpMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        uint256 c = a + b;\n+        require(c >= a, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b <= a, errorMessage);\n+        /// BinaryOpMutation(`-` |==> `+`) of: `uint256 c = a - b;`\n+        uint256 c = a+b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    uint256 public totalSupply = 10*(10**18);\n+    uint256 public MaxSupply = 10*(10**(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        owner= msg.sender;\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "9",
    "name": "mutants/9/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  },
  {
    "description": "BinaryOpMutation",
    "diff": "--- original\n+++ mutant\n@@ -1,221 +1,222 @@\n-pragma solidity ^0.5.0;\r\n-\r\n-library SafeMath {\r\n-    /**\r\n-     * @dev Returns the addition of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `+` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Addition cannot overflow.\r\n-     */\r\n-    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        uint256 c = a + b;\r\n-        require(c >= a, \"SafeMath: addition overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n-     * overflow (when the result is negative).\r\n-     *\r\n-     * Counterpart to Solidity's `-` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Subtraction cannot overflow.\r\n-     */\r\n-    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b <= a, errorMessage);\r\n-        uint256 c = a - b;\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n-     * overflow.\r\n-     *\r\n-     * Counterpart to Solidity's `*` operator.\r\n-     *\r\n-     * Requirements:\r\n-     * - Multiplication cannot overflow.\r\n-     */\r\n-    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n-        // benefit is lost if 'b' is also tested.\r\n-        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n-        if (a == 0) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        uint256 c = a * b;\r\n-        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return div(a, b, \"SafeMath: division by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n-     * division by zero. The result is rounded towards zero.\r\n-     *\r\n-     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n-     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n-     * uses an invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        // Solidity only automatically asserts when dividing by 0\r\n-        require(b > 0, errorMessage);\r\n-        uint256 c = a / b;\r\n-        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n-\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n-        return mod(a, b, \"SafeMath: modulo by zero\");\r\n-    }\r\n-\r\n-    /**\r\n-     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n-     * Reverts with custom message when dividing by zero.\r\n-     *\r\n-     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n-     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n-     * invalid opcode to revert (consuming all remaining gas).\r\n-     *\r\n-     * Requirements:\r\n-     * - The divisor cannot be zero.\r\n-     */\r\n-    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n-        require(b != 0, errorMessage);\r\n-        return a % b;\r\n-    }\r\n-}\r\n-\r\n-contract clashPay {\r\n-    using SafeMath for uint256;\r\n-    string  public name = \"Clash Pay\";\r\n-    string  public symbol = \"SCP\";\r\n-    uint8   public decimals = 18;\r\n-    uint256 public totalSupply = 10*(10**18);\r\n-    uint256 public MaxSupply = 10*(10**(29));\r\n-    address public owner;\r\n-    address public Tokenfarm;\r\n-\r\n-    event Transfer(\r\n-        address indexed _from,\r\n-        address indexed _to,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    event Burn(\r\n-        address indexed burner,\r\n-        uint256 value\r\n-    );\r\n-\r\n-    event Approval(\r\n-        address indexed _owner,\r\n-        address indexed _spender,\r\n-        uint256 _value\r\n-    );\r\n-\r\n-    mapping(address => uint256) public balanceOf;\r\n-    mapping(address => mapping(address => uint256)) public allowance;\r\n-\r\n-    constructor() public {\r\n-        balanceOf[msg.sender] = totalSupply;\r\n-        owner= msg.sender;\r\n-    }\r\n-    function setContract(address _contract) external{\r\n-        require(msg.sender==owner,\"must be owner\");\r\n-        Tokenfarm=_contract;\r\n-    }\r\n-\r\n-    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        emit Transfer(msg.sender, _to, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function approve(address _spender, uint256 _value) external returns (bool success) {\r\n-        allowance[msg.sender][_spender] = _value;\r\n-        emit Approval(msg.sender, _spender, _value);\r\n-        return true;\r\n-    }\r\n-\r\n-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n-        require(address(0)!= _to,\"to burn tokens use the burn function\");\r\n-        balanceOf[_from] = balanceOf[_from].sub( _value);\r\n-        balanceOf[_to] = balanceOf[_to].add( _value);\r\n-        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\r\n-        emit Transfer(_from, _to, _value);\r\n-        return true;\r\n-    }\r\n-    function mint(address _to,uint256 _value) public {\r\n-        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\r\n-        if(totalSupply.add(_value)>=MaxSupply){\r\n-            _value = MaxSupply.sub(totalSupply);\r\n-        }\r\n-        totalSupply= totalSupply.add( _value);\r\n-        balanceOf[_to]=balanceOf[_to].add(_value);\r\n-        emit Transfer(address(0),_to,_value);\r\n-    }\r\n-    function burn(uint256 _value) public{\r\n-        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\r\n-        totalSupply = totalSupply.sub(_value);\r\n-        emit Burn(msg.sender,_value);\r\n-        emit Transfer(msg.sender,address(0),_value);\r\n-    }\r\n-    function transferOwnership(address _newOwner) external{\r\n-        require(msg.sender==owner,\"only the owner an call this function\");\r\n-        owner=_newOwner;\r\n-\r\n-    }\r\n-\r\n+pragma solidity ^0.5.0;\n+\n+library SafeMath {\n+    /**\n+     * @dev Returns the addition of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `+` operator.\n+     *\n+     * Requirements:\n+     * - Addition cannot overflow.\n+     */\n+    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n+        uint256 c = a + b;\n+        require(c >= a, \"SafeMath: addition overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return sub(a, b, \"SafeMath: subtraction overflow\");\n+    }\n+\n+    /**\n+     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n+     * overflow (when the result is negative).\n+     *\n+     * Counterpart to Solidity's `-` operator.\n+     *\n+     * Requirements:\n+     * - Subtraction cannot overflow.\n+     */\n+    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b <= a, errorMessage);\n+        /// BinaryOpMutation(`-` |==> `/`) of: `uint256 c = a - b;`\n+        uint256 c = a/b;\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the multiplication of two unsigned integers, reverting on\n+     * overflow.\n+     *\n+     * Counterpart to Solidity's `*` operator.\n+     *\n+     * Requirements:\n+     * - Multiplication cannot overflow.\n+     */\n+    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n+        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n+        // benefit is lost if 'b' is also tested.\n+        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n+        if (a == 0) {\n+            return 0;\n+        }\n+\n+        uint256 c = a * b;\n+        require(c / a == b, \"SafeMath: multiplication overflow\");\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return div(a, b, \"SafeMath: division by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n+     * division by zero. The result is rounded towards zero.\n+     *\n+     * Counterpart to Solidity's `/` operator. Note: this function uses a\n+     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n+     * uses an invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        // Solidity only automatically asserts when dividing by 0\n+        require(b > 0, errorMessage);\n+        uint256 c = a / b;\n+        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n+\n+        return c;\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n+        return mod(a, b, \"SafeMath: modulo by zero\");\n+    }\n+\n+    /**\n+     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n+     * Reverts with custom message when dividing by zero.\n+     *\n+     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n+     * opcode (which leaves remaining gas untouched) while Solidity uses an\n+     * invalid opcode to revert (consuming all remaining gas).\n+     *\n+     * Requirements:\n+     * - The divisor cannot be zero.\n+     */\n+    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n+        require(b != 0, errorMessage);\n+        return a % b;\n+    }\n+}\n+\n+contract clashPay {\n+    using SafeMath for uint256;\n+    string  public name = \"Clash Pay\";\n+    string  public symbol = \"SCP\";\n+    uint8   public decimals = 18;\n+    uint256 public totalSupply = 10*(10**18);\n+    uint256 public MaxSupply = 10*(10**(29));\n+    address public owner;\n+    address public Tokenfarm;\n+\n+    event Transfer(\n+        address indexed _from,\n+        address indexed _to,\n+        uint256 _value\n+    );\n+\n+    event Burn(\n+        address indexed burner,\n+        uint256 value\n+    );\n+\n+    event Approval(\n+        address indexed _owner,\n+        address indexed _spender,\n+        uint256 _value\n+    );\n+\n+    mapping(address => uint256) public balanceOf;\n+    mapping(address => mapping(address => uint256)) public allowance;\n+\n+    constructor() public {\n+        balanceOf[msg.sender] = totalSupply;\n+        owner= msg.sender;\n+    }\n+    function setContract(address _contract) external{\n+        require(msg.sender==owner,\"must be owner\");\n+        Tokenfarm=_contract;\n+    }\n+\n+    function transfer(address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        emit Transfer(msg.sender, _to, _value);\n+        return true;\n+    }\n+\n+    function approve(address _spender, uint256 _value) external returns (bool success) {\n+        allowance[msg.sender][_spender] = _value;\n+        emit Approval(msg.sender, _spender, _value);\n+        return true;\n+    }\n+\n+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n+        require(address(0)!= _to,\"to burn tokens use the burn function\");\n+        balanceOf[_from] = balanceOf[_from].sub( _value);\n+        balanceOf[_to] = balanceOf[_to].add( _value);\n+        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n+        emit Transfer(_from, _to, _value);\n+        return true;\n+    }\n+    function mint(address _to,uint256 _value) public {\n+        require(msg.sender==Tokenfarm,\"only Tokenfarm contract can mint tokens\");\n+        if(totalSupply.add(_value)>=MaxSupply){\n+            _value = MaxSupply.sub(totalSupply);\n+        }\n+        totalSupply= totalSupply.add( _value);\n+        balanceOf[_to]=balanceOf[_to].add(_value);\n+        emit Transfer(address(0),_to,_value);\n+    }\n+    function burn(uint256 _value) public{\n+        balanceOf[msg.sender] =balanceOf[msg.sender].sub( _value);\n+        totalSupply = totalSupply.sub(_value);\n+        emit Burn(msg.sender,_value);\n+        emit Transfer(msg.sender,address(0),_value);\n+    }\n+    function transferOwnership(address _newOwner) external{\n+        require(msg.sender==owner,\"only the owner an call this function\");\n+        owner=_newOwner;\n+\n+    }\n+\n }\n\\ No newline at end of file\n",
    "id": "10",
    "name": "mutants/10/verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "original": "verisol_test/0xb934c43268adaedee892c4e8d3d56b010498e80c.etherscan.io-clashPay.sol",
    "sourceroot": "/home/liuye/Projects/InvConPlus"
  }
]